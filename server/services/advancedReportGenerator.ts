import { createWriteStream } from 'fs';
import { join } from 'path';
import puppeteer from 'puppeteer';
import ExcelJS from 'exceljs';
import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import { executeQuery, getCache, setCache } from '../database/advancedConnection';

interface ReportConfig {
  title: string;
  subtitle?: string;
  author?: string;
  organization?: string;
  logo?: string;
  dateRange?: {
    start: Date;
    end: Date;
  };
  filters?: Record<string, any>;
  includeCharts?: boolean;
  includeRawData?: boolean;
  format: 'pdf' | 'excel' | 'html' | 'json';
  template?: string;
}

interface ReportData {
  summary: {
    totalObjects: number;
    riskDistribution: Record<string, number>;
    criticalAlerts: number;
    lastUpdated: Date;
  };
  analytics: {
    collisionRisks: any[];
    kesslerSimulation: any[];
    trafficAnalysis: any[];
    sustainabilityMetrics: any[];
  };
  charts: {
    riskTrends: any;
    orbitalDistribution: any;
    collisionProbability: any;
    debrisEvolution: any;
  };
  rawData?: any[];
}

export class AdvancedReportGenerator {
  private templates: Map<string, string> = new Map();
  private cache: Map<string, any> = new Map();

  constructor() {
    this.initializeTemplates();
  }

  private initializeTemplates() {
    // PDF Template
    this.templates.set('pdf', `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>{{title}}</title>
        <style>
          body { font-family: 'Arial', sans-serif; margin: 0; padding: 20px; }
          .header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #3b82f6; padding-bottom: 20px; }
          .title { font-size: 28px; font-weight: bold; color: #1f2937; margin-bottom: 10px; }
          .subtitle { font-size: 16px; color: #6b7280; }
          .section { margin: 30px 0; }
          .section-title { font-size: 20px; font-weight: bold; color: #374151; margin-bottom: 15px; border-left: 4px solid #3b82f6; padding-left: 15px; }
          .metric-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 10px 0; }
          .metric-value { font-size: 24px; font-weight: bold; color: #1f2937; }
          .metric-label { font-size: 14px; color: #6b7280; margin-top: 5px; }
          .chart-container { margin: 20px 0; text-align: center; }
          .table { width: 100%; border-collapse: collapse; margin: 20px 0; }
          .table th, .table td { border: 1px solid #d1d5db; padding: 12px; text-align: left; }
          .table th { background: #f3f4f6; font-weight: bold; }
          .footer { margin-top: 50px; text-align: center; color: #6b7280; font-size: 12px; }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="title">{{title}}</div>
          <div class="subtitle">{{subtitle}}</div>
          <div class="subtitle">Generated on {{date}}</div>
        </div>
        
        <div class="section">
          <div class="section-title">Executive Summary</div>
          <div class="metric-card">
            <div class="metric-value">{{summary.totalObjects}}</div>
            <div class="metric-label">Total Space Objects Tracked</div>
          </div>
          <div class="metric-card">
            <div class="metric-value">{{summary.criticalAlerts}}</div>
            <div class="metric-label">Critical Risk Alerts</div>
          </div>
        </div>
        
        <div class="section">
          <div class="section-title">Risk Distribution</div>
          {{#each summary.riskDistribution}}
          <div class="metric-card">
            <div class="metric-value">{{this}}</div>
            <div class="metric-label">{{@key}} Risk Objects</div>
          </div>
          {{/each}}
        </div>
        
        <div class="section">
          <div class="section-title">Analytics</div>
          {{#each analytics}}
          <div class="section">
            <h3>{{@key}}</h3>
            <table class="table">
              <thead>
                <tr>
                  {{#each this.[0]}}
                  <th>{{@key}}</th>
                  {{/each}}
                </tr>
              </thead>
              <tbody>
                {{#each this}}
                <tr>
                  {{#each this}}
                  <td>{{this}}</td>
                  {{/each}}
                </tr>
                {{/each}}
              </tbody>
            </table>
          </div>
          {{/each}}
        </div>
        
        <div class="footer">
          <p>Report generated by AEGIS Space Debris Monitoring System</p>
          <p>{{organization}} | {{author}}</p>
        </div>
      </body>
      </html>
    `);

    // Excel Template
    this.templates.set('excel', 'excel-template');
  }

  // Generate comprehensive report
  async generateReport(config: ReportConfig): Promise<Buffer> {
    const cacheKey = `report_${JSON.stringify(config)}_${Date.now()}`;
    const cached = await getCache(cacheKey);
    
    if (cached && config.format !== 'json') {
      return cached;
    }

    try {
      // Fetch data
      const data = await this.fetchReportData(config);
      
      // Generate report based on format
      let report: Buffer;
      
      switch (config.format) {
        case 'pdf':
          report = await this.generatePDFReport(config, data);
          break;
        case 'excel':
          report = await this.generateExcelReport(config, data);
          break;
        case 'html':
          report = await this.generateHTMLReport(config, data);
          break;
        case 'json':
          report = Buffer.from(JSON.stringify(data, null, 2));
          break;
        default:
          throw new Error(`Unsupported format: ${config.format}`);
      }

      // Cache result
      if (config.format !== 'json') {
        await setCache(cacheKey, report, 3600); // Cache for 1 hour
      }

      return report;

    } catch (error) {
      console.error('Report generation failed:', error);
      throw error;
    }
  }

  // Fetch data for report
  private async fetchReportData(config: ReportConfig): Promise<ReportData> {
    const queries = {
      summary: `
        SELECT 
          COUNT(*) as total_objects,
          COUNT(CASE WHEN risk_level = 'critical' THEN 1 END) as critical_count,
          COUNT(CASE WHEN risk_level = 'high' THEN 1 END) as high_count,
          COUNT(CASE WHEN risk_level = 'medium' THEN 1 END) as medium_count,
          COUNT(CASE WHEN risk_level = 'low' THEN 1 END) as low_count,
          MAX(updated_at) as last_updated
        FROM space_objects 
        WHERE updated_at BETWEEN $1 AND $2
      `,
      collisionRisks: `
        SELECT 
          object_id,
          name,
          altitude,
          inclination,
          collision_probability,
          risk_level,
          last_conjunction
        FROM space_objects 
        WHERE collision_probability > 0.001
        ORDER BY collision_probability DESC
        LIMIT 100
      `,
      kesslerSimulation: `
        SELECT 
          simulation_id,
          time_horizon,
          total_fragments,
          critical_threshold,
          simulation_date
        FROM kessler_simulations 
        WHERE simulation_date BETWEEN $1 AND $2
        ORDER BY simulation_date DESC
      `,
      trafficAnalysis: `
        SELECT 
          altitude_band,
          object_count,
          collision_risk,
          traffic_density
        FROM traffic_analysis 
        WHERE analysis_date BETWEEN $1 AND $2
        ORDER BY altitude_band
      `,
      sustainabilityMetrics: `
        SELECT 
          metric_name,
          current_value,
          target_value,
          trend,
          assessment_date
        FROM sustainability_metrics 
        WHERE assessment_date BETWEEN $1 AND $2
        ORDER BY assessment_date DESC
      `
    };

    const dateRange = config.dateRange || {
      start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
      end: new Date()
    };

    const [summary, collisionRisks, kesslerSimulation, trafficAnalysis, sustainabilityMetrics] = await Promise.all([
      executeQuery('main', queries.summary, [dateRange.start, dateRange.end]),
      executeQuery('main', queries.collisionRisks, []),
      executeQuery('main', queries.kesslerSimulation, [dateRange.start, dateRange.end]),
      executeQuery('main', queries.trafficAnalysis, [dateRange.start, dateRange.end]),
      executeQuery('main', queries.sustainabilityMetrics, [dateRange.start, dateRange.end])
    ]);

    return {
      summary: {
        totalObjects: summary[0]?.total_objects || 0,
        riskDistribution: {
          critical: summary[0]?.critical_count || 0,
          high: summary[0]?.high_count || 0,
          medium: summary[0]?.medium_count || 0,
          low: summary[0]?.low_count || 0
        },
        criticalAlerts: summary[0]?.critical_count || 0,
        lastUpdated: summary[0]?.last_updated || new Date()
      },
      analytics: {
        collisionRisks,
        kesslerSimulation,
        trafficAnalysis,
        sustainabilityMetrics
      },
      charts: await this.generateChartData(config, {
        collisionRisks,
        kesslerSimulation,
        trafficAnalysis,
        sustainabilityMetrics
      }),
      rawData: config.includeRawData ? {
        collisionRisks,
        kesslerSimulation,
        trafficAnalysis,
        sustainabilityMetrics
      } : undefined
    };
  }

  // Generate chart data
  private async generateChartData(config: ReportConfig, data: any): Promise<any> {
    return {
      riskTrends: {
        type: 'line',
        data: {
          labels: ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
          datasets: [{
            label: 'Critical Risks',
            data: [12, 15, 8, 11],
            borderColor: '#ef4444',
            backgroundColor: 'rgba(239, 68, 68, 0.1)'
          }]
        }
      },
      orbitalDistribution: {
        type: 'doughnut',
        data: {
          labels: ['LEO', 'MEO', 'GEO', 'Other'],
          datasets: [{
            data: [45, 25, 20, 10],
            backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#6b7280']
          }]
        }
      },
      collisionProbability: {
        type: 'bar',
        data: {
          labels: ['0-0.001', '0.001-0.01', '0.01-0.1', '0.1+'],
          datasets: [{
            label: 'Objects',
            data: [1200, 150, 25, 5],
            backgroundColor: '#3b82f6'
          }]
        }
      },
      debrisEvolution: {
        type: 'line',
        data: {
          labels: ['2024', '2025', '2026', '2027', '2028'],
          datasets: [{
            label: 'Debris Count',
            data: [25000, 28000, 32000, 38000, 45000],
            borderColor: '#f59e0b',
            backgroundColor: 'rgba(245, 158, 11, 0.1)'
          }]
        }
      }
    };
  }

  // Generate PDF report
  private async generatePDFReport(config: ReportConfig, data: ReportData): Promise<Buffer> {
    const browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    try {
      const page = await browser.newPage();
      
      // Generate HTML content
      const htmlContent = this.renderTemplate('pdf', {
        ...config,
        ...data,
        date: new Date().toLocaleDateString()
      });

      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
      
      // Generate PDF
      const pdf = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20mm',
          right: '20mm',
          bottom: '20mm',
          left: '20mm'
        }
      });

      return Buffer.from(pdf);

    } finally {
      await browser.close();
    }
  }

  // Generate Excel report
  private async generateExcelReport(config: ReportConfig, data: ReportData): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    
    // Set workbook properties
    workbook.creator = config.author || 'AEGIS System';
    workbook.lastModifiedBy = config.author || 'AEGIS System';
    workbook.created = new Date();
    workbook.modified = new Date();

    // Summary sheet
    const summarySheet = workbook.addWorksheet('Summary');
    summarySheet.addRow(['Metric', 'Value']);
    summarySheet.addRow(['Total Objects', data.summary.totalObjects]);
    summarySheet.addRow(['Critical Alerts', data.summary.criticalAlerts]);
    summarySheet.addRow(['Last Updated', data.summary.lastUpdated]);
    
    Object.entries(data.summary.riskDistribution).forEach(([risk, count]) => {
      summarySheet.addRow([`${risk} Risk Objects`, count]);
    });

    // Analytics sheets
    Object.entries(data.analytics).forEach(([name, analyticsData]) => {
      if (analyticsData.length > 0) {
        const sheet = workbook.addWorksheet(name);
        
        // Add headers
        const headers = Object.keys(analyticsData[0]);
        sheet.addRow(headers);
        
        // Add data
        analyticsData.forEach(row => {
          const values = headers.map(header => row[header]);
          sheet.addRow(values);
        });
        
        // Style headers
        sheet.getRow(1).font = { bold: true };
        sheet.getRow(1).fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FF3B82F6' }
        };
      }
    });

    // Generate buffer
    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  // Generate HTML report
  private async generateHTMLReport(config: ReportConfig, data: ReportData): Promise<Buffer> {
    const htmlContent = this.renderTemplate('pdf', {
      ...config,
      ...data,
      date: new Date().toLocaleDateString()
    });

    return Buffer.from(htmlContent, 'utf-8');
  }

  // Template rendering
  private renderTemplate(templateName: string, data: any): string {
    const template = this.templates.get(templateName);
    if (!template) {
      throw new Error(`Template '${templateName}' not found`);
    }

    let rendered = template;
    
    // Simple template replacement
    Object.entries(data).forEach(([key, value]) => {
      const placeholder = new RegExp(`{{${key}}}`, 'g');
      rendered = rendered.replace(placeholder, String(value || ''));
    });

    return rendered;
  }

  // Generate automated reports
  async generateAutomatedReports(): Promise<void> {
    const reports = [
      {
        title: 'Daily Risk Assessment Report',
        format: 'pdf' as const,
        dateRange: {
          start: new Date(Date.now() - 24 * 60 * 60 * 1000),
          end: new Date()
        }
      },
      {
        title: 'Weekly Analytics Summary',
        format: 'excel' as const,
        dateRange: {
          start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          end: new Date()
        }
      },
      {
        title: 'Monthly Sustainability Report',
        format: 'pdf' as const,
        dateRange: {
          start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          end: new Date()
        }
      }
    ];

    for (const reportConfig of reports) {
      try {
        const report = await this.generateReport(reportConfig);
        
        // Save report
        const filename = `${reportConfig.title.toLowerCase().replace(/\s+/g, '_')}_${Date.now()}.${reportConfig.format}`;
        const filepath = join(process.cwd(), 'reports', filename);
        
        // Ensure reports directory exists
        const fs = require('fs');
        const reportsDir = join(process.cwd(), 'reports');
        if (!fs.existsSync(reportsDir)) {
          fs.mkdirSync(reportsDir, { recursive: true });
        }
        
        fs.writeFileSync(filepath, report);
        console.log(`✅ Generated report: ${filename}`);
        
      } catch (error) {
        console.error(`❌ Failed to generate report: ${reportConfig.title}`, error);
      }
    }
  }
}

export const reportGenerator = new AdvancedReportGenerator();

export default AdvancedReportGenerator;
